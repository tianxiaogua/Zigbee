#  zigbee CC2530芯片概述

CC2530由TI公司生产的推出的支持协议栈的芯片；设备特点：

​	蓝牙：功耗低。

​	WiFi：通讯速率大

​	zigbee：功率低，可组建大规模网络。但是通讯速率比较低。速度250kbps，功耗一般8mh。最低2微安

​	



#  一、IO的基本控制

##  控制一个IO的输出：

首先需要令该IO设置未普通IO的模式，如：P0SEL，P1SEL，P2SEL,一共就只有这三个寄存器来设置

让该IO设置未输出状态，而非输出状态，如：P0DIR，P1DIR，P2DIR

最后直接设置该IO未输出高低电平，如：P1_0 = 0;

```c
  P1SEL &= 0XFE; //普通IO寄存器，非外设模式定义寄存器 ，该寄存器处于1时是外设模式，0是普通IO模式
  P1DIR |= 0X01;  //设置IO处于输出状态，0是输出状态，1是输出状态
  P1_0  =  1; //设置IO的寄存器的值
```



##  设置一个IO的输入：

和设置输出模式相同都需要设置三个寄存器，还需要配置上下拉模式：
1、设置为普通IO模式，配置P0SEL，P1SEL，P2SEL；

2、设置输入输出模式，配置P0DIR，P1DIR，P2DIR；

3、设置IO的输入为上拉、下拉或者三态状态，需要配置P0INP、P1INP、P2INP；

​	一般情况下，读取外部开关信号直接设置上下拉模式，读取AD信号一般使用三态状态模式

4、通过读取IO的寄存器读取IO的状态

特别需要注意的是PXINP寄存器，在输出模式下，该寄存器的每一位都对用了相对应的IO，0表示上下拉模式。1表示三态模式。但是由于设置为上下拉模式还要具体到设置为上拉模式或者下拉模式，因此，使用P2INP的高三为进行设置，把第五位设置为0就是上拉模式，1就是下拉模式：

```c
P0SEL &= 0xBF;     //设置P0.1为普通IO口 1011111 
P0DIR &= 0xBF;     //按键接在P0.1口上，设P0.1为输入模式  101111
P0INP &= 0xBF;     //设置IO的模式为上下拉模式。 101111
P2INP &= 0xDF	   //设置IO 1101 1111
```
初始状态下的一些寄存器的值都是零，因此一些寄存器就不需要配置！！！

因此芯片在上电后吗，默认是所有的IO口都是上拉输出状态！！！



#  配置IO的外部中断：

注意：CC2530的每一个IO引脚都有中断功能；

1、初始化IO为普通IO模式；

2、配置IO的输入模式；

3、配置IO的上下拉；

4、配置上拉；

5、开启CPU中断，令EA = 1；

​	相当于一个最高级别的开关，控制所有IO的中断信号，只有这一位寄存器设置为1的时候才会开启中断；

6、打卡IO口组中断；一共三组，分别是P0组、P1组和P2组。

​	对应的寄存器为：P0IE、P1IE和P2IE；是一个只有1位的寄存器。相当于一个总开关下面的次级开关。分别控制了三组IO的中断信号。并且规定0是关断使能，1是开启使能；

7、打开组内的对应的某个IO的中断；相应为具体的某一个IO。

​	一共有三组寄存器，每个寄存器的八位对应了8个IO，可以进行分别控制。这三个寄存器是P0IEM、P1IEM和P2IEM。规定0代表复位，1代表使能；

8、确定上升沿触发还是下降；

​	只由单独的一个寄存器配置所有IO。0代表上升沿，1代表下降沿；

​	每一位分别对应了不同组的IO：

| 7          | 6    | 5    | 4    | 3         | 2         | 1         | 0         |
| ---------- | ---- | ---- | ---- | --------- | --------- | --------- | --------- |
| IO驱动能力 | 无   | 无   | 无   | P2_0~P2_4 | P1_4~P1_7 | P1_0~P1_3 | P0_0~P0_7 |

具体到一个IO的设置如下：

```c
//配置P0_5的外部中断为例
P0SEF &= 0XDF; //设置IO为普通IO  1101 1111
P0DIR &= 0XDF; //设置为输入模式   1101 1111
POINP &= 0XDF; //设置为上下拉模式 1101 1111
P2INP &= 0XDF; //设置为上拉模式   1101 1111

EA = 1; //开启中断总开关
P0IE = 1; //开启中断组开关
P0IEN |= 0X20; //开启中断IO开关 0010 0000

PICTL |= 0X01; //设置P0_0~P0_7为下降沿触发模式 0000 0001
```

设置中断函数,都是固定格式

```c
#pragma optimze=none
#pragma vector=P0INT_VECTOR
__interrup void a_function()
{
    if(P0IFG & 0X20) //读取中断寄存器的值，八位宽分别对应了8个IO的的值；这里对应的是第五位：0010 0000
    {
        do_something(); //中断后实现的具体功能
    }
	P0IFG = 0; //让中断寄存器的值清除
    P0IF = 0; //组中断寄存器的值清除
}
```



#  二、CC2530的时钟配置



##  概述

CC2530同样也有两个时钟，一个是高频时钟信号给CPU使用，另一个低频时钟信号给看门狗，睡眠定时器等使用；

相对应的高速时钟CC2530片内有一个16MHz的RC振荡器，也可以使用外接32M时钟晶振，同样的低速时钟也有片外和片内两个，同时如果需要外设和看门狗等，需要设置一个低频的时钟信号，而且内部也有一个低频RC震荡电路。

因此CC2530在完全不接外部晶振的情况下也可以正常工作；

**如果使用串口，或者进行通讯的时候，都需要设置为32MHz的时钟信号，否则将不能正常工作！**

**在配置竟真的时候两个高频时钟源可以同时起振，但是只能有一个供给CPU。**



## 配置32MHz晶振的过程

把默认的16MHzRC振荡器更换为外部32MHz晶振

1、开始需要先让两个时钟源同时开始震荡，就是让SLEEPCMD的第二位为零；

2、之后需要等待时钟源的稳定。即读取SLEEPSTA寄存器的第六位，为1时表示32MHz的时钟源已经稳定了；

3、产生一个63微妙以上的延时；

4、设置32MHz的时钟为不分频的输出，即把寄存器CLKCONCMD的低三位设置为000，表示不分频；

5、选中高频的时钟源作为系统的主时钟，即把寄存器CLKCONCMD的第六位清零，表示令32MHz的时钟源为系统主时钟；

6、最后如果读取的CLKCONSTA这个寄存器的第六位为0，表示32MHz的时钟已经作为了当前的系统主时钟，程序可以继续运行；

下面的代码展示了更换工作频率的过程：

```c
/****************************************************************************
* 名    称: sys32_clk_init()
* 功    能: 把系统时钟设置为32MHz
* 入口参数: 无
* 出口参数: 无
****************************************************************************/
void sys32_clk_init(void)
{
  /*开始需要先让两个时钟源同时开始震荡，就是让SLEEPCMD的第二位为零;---------------------------------------------------*/
  SLEEPCMD &= 0xFB; 
  
  /*之后需要等待时钟源的稳定。即读取SLEEPSTA寄存器的第六位，为1时表示32MHz的时钟源已经稳定了；------------------------*/
  while(0 == (SLEEPSTA & 0x40));
  
  /*产生一个63微妙以上的延时；---------------------------------------------------------------------------------------*/
  for(int i=0;i<1000;i++) for(int j=0; j<800; j++);
  
  /*设置32MHz的时钟为不分频的输出，即把寄存器CLKCONCMD的低三位设置为000，表示不分频；--------------------------------*/
  CLKCONCMD &= 0xF8;
  
  //选中高频的时钟源作为系统的主时钟，即把寄存器CLKCONCMD的第六位清零，表示令32MHz的时钟源为系统主时钟；--------------*/
  CLKCONCMD &= 0xBF;
  
  /*最后如果读取的CLKCONSTA这个寄存器的第六位为0，表示32MHz的时钟已经作为了当前的系统主时钟，程序可以继续运行；-------*/
  while(CLKCONSTA & 0x40);
  
}
```



#  三、配置串口

CC2530上可以配置两个串口，分别是串口0和串口1，是片上外设。需要对其寄存器进行控制

串口的配置过程：

1、指定串口的IO的位置；

2、对相应的IO配置成片上外设功能；

3、对8个数据位，一个停止位，无流控以及无校验寄存器控制；

4、设置波特率；

5、打开CPU中断；

6、配置对应的串口中断和串口中断函数；

下面的代码展示了配置串口的初始化函数：

```c
/****************************************************************************
* 名    称: uart0_init()
* 功    能: 对串口0进行初始化
* 入口参数: 波特率的大小，可以设置为115200或者9600，输入其他值默认代表115200
* 出口参数: 无
****************************************************************************/
void uart0_init(long int rate)
{ 
    PERCFG = 0x00;           //外设控制寄存器 USART 0的IO位置:0为P0口位置1 
    
    P0SEL = 0x0c;            //P0_2,P0_3用作串口（外设功能）
    
    P2DIR &= ~0xC0;          //P0优先作为UART0
    
    U0CSR |= 0x80;           //设置为UART方式
   
    switch(rate)
    {
      case 115200: {  U0GCR |= 11;  U0BAUD |= 216;} break;           //波特率设为115200
      
      case 9600  : {  U0GCR |= 8;  U0BAUD |= 59 ; }break;           //波特率设为115200
      
      default:U0BAUD |= 216;            //波特率设为115200
    }
    
    UTX0IF = 0;              //UART0 TX中断标志初始置位0
    
    U0CSR |= 0x40;           //允许接收 
    
    IEN0 |= 0x84;            //开总中断允许接收中断  
}
```



下面的代码展示了串口发送数据的函数：

```c
/****************************************************************************
* 名    称: printf()
* 功    能: 串口发送函数 !!!需要包含string.h头文件
* 入口参数: Data:发送缓冲区
* 出口参数: 无
****************************************************************************/
void printf(char *a_string_data)
{
    u16 qwq;
    u16 length_qwq;
    length_qwq = strlen(a_string_data); //判断要发送的字符串的长度
    for(qwq=0; qwq<length_qwq; qwq++)
    {
        U0DBUF = *a_string_data++; //一个一个字节的发送和更新数据
        while(UTX0IF == 0); //判断是否已经发送完成
        UTX0IF = 0;
    }
}
```



下面的代码展示了串口中断函数，可以接收串口接收到的数据：

```c
/****************************************************************************
* 名    称: 串口中断处理函数 
* 描    述: 当串口0产生接收中断，将收到的数据保存在RxBuf中
****************************************************************************/
#pragma vector = URX0_VECTOR 
__interrupt void UART0_ISR(void) 
{ 
    int j;
    static int qwq;
    char RxBuf;
    static char data[255];
    
    URX0IF = 0;       // 清中断标志 
    RxBuf = U0DBUF;   //读出串口里的数据  
    if((qwq < 255))//一次最多接收50个字符             
      data[qwq++] = RxBuf; 
    if(RxBuf == '\n') //检测接收到了最后一个字符
    {
      for (j=0;j<255;j++) sdata[j] = data[j];  //把接收到的全局变量先传递出
      memset(data, 0, 255);//清空接收缓冲区
      qwq=0;
    }
}
```





































































